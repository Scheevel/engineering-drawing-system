# Test Design: Story 3.16 - Schema Change Audit Trail System

**Date:** 2025-10-12
**Designer:** Quinn (Test Architect)
**Story:** 3.16 - Schema Change Audit Trail System

---

## Test Strategy Overview

- **Total test scenarios:** 18 tests (12 P0, 5 P1, 1 P2)
- **Unit tests:** 6 (33%)
- **Integration tests:** 8 (44%)
- **API tests:** 3 (17%)
- **E2E tests:** 1 (6%)
- **Priority distribution:** P0: 12, P1: 5, P2: 1

**Testing Philosophy:**

This audit trail feature requires **thorough backend testing** with lighter frontend validation:

- **Backend-heavy**: Audit correctness is critical for data integrity and compliance
- **Unit tests** for AuditService business logic
- **Integration tests** for schema change workflows and transaction behavior
- **API tests** for endpoint contracts
- **Minimal E2E** since audit is transparent to users (background operation)

---

## Test Scenarios by Acceptance Criteria

### Backend Audit System (AC1-8)

#### AC1: Audit Record Creation (2 linked records with same session_id)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-UNIT-001** | Unit | **P0** | `test_create_schema_change_audit_creates_two_records()` - Verify AuditService creates exactly 2 audit records | Tests core audit creation logic in isolation |
| **3.16-UNIT-002** | Unit | **P0** | `test_audit_records_share_session_id()` - Verify both records have identical session_id | Tests session linking logic |
| **3.16-INT-001** | Integration | **P0** | `test_schema_change_A_to_B_creates_linked_audit()` - Full workflow: change schema, verify 2 records created with matching session_id | Validates end-to-end AC1 requirement |

**Coverage:** ✅ 3 tests (2 unit, 1 integration)
**Mitigates Risks:** Data loss, audit integrity

---

#### AC2: Schema Record Format (field_name="schema_id", old/new UUIDs)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-UNIT-003** | Unit | **P0** | `test_schema_record_has_correct_field_name()` - Verify first audit record has `field_name="schema_id"` | Tests field naming logic |
| **3.16-INT-002** | Integration | **P0** | `test_schema_record_captures_old_and_new_uuids()` - Verify old_value contains old schema UUID, new_value contains new schema UUID | Validates AC2 requirement with real component data |

**Coverage:** ✅ 2 tests (1 unit, 1 integration)
**Mitigates Risks:** Incorrect audit structure, schema tracking failure

---

#### AC3: Data Preservation Record (field_name="dynamic_data", JSON string)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-UNIT-004** | Unit | **P0** | `test_dynamic_data_record_has_correct_field_name()` - Verify second audit record has `field_name="dynamic_data"` | Tests field naming logic |
| **3.16-UNIT-005** | Unit | **P0** | `test_json_serialization_of_dynamic_data()` - Verify JSONB to JSON string conversion handles complex data (nested objects, arrays, numbers, booleans) | Tests serialization correctness |
| **3.16-INT-003** | Integration | **P0** | `test_dynamic_data_preservation_with_real_component()` - Create component with dynamic_data, change schema, verify old data preserved as JSON string | Validates AC3 requirement end-to-end |

**Coverage:** ✅ 3 tests (2 unit, 1 integration)
**Mitigates Risks:** Data loss, serialization errors

---

#### AC4: Skip First Assignment (old_schema_id IS NULL)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-UNIT-006** | Unit | **P0** | `test_skip_audit_when_old_schema_is_null()` - Pass `old_schema_id=None` to AuditService, verify no records created (or exception raised) | Tests NULL guard logic in isolation |
| **3.16-INT-004** | Integration | **P0** | `test_first_schema_assignment_skips_audit()` - Create component without schema, assign first schema, verify 0 audit records | Validates AC4 requirement with real component lifecycle |

**Coverage:** ✅ 2 tests (1 unit, 1 integration)
**Mitigates Risks:** Unnecessary audit records, audit table bloat

---

#### AC5: Skip Same Schema (old_schema_id == new_schema_id)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-INT-005** | Integration | **P0** | `test_same_schema_update_skips_audit()` - Update component with same schema_id, verify 0 audit records created | Integration level because guard is in FlexibleComponentService, not AuditService |

**Coverage:** ✅ 1 test (integration)
**Mitigates Risks:** Unnecessary audit records, audit table bloat

**Note:** AC5 is implemented at the FlexibleComponentService level (line 103 condition), so unit testing would require mocking the entire service. Integration test is more appropriate.

---

#### AC6: Transaction Integrity (audit failure → rollback)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-INT-006** | Integration | **P0** | `test_audit_failure_rolls_back_schema_change()` - Mock db.flush() to raise exception, verify schema_id unchanged and no audit records created | Tests critical transaction behavior |

**Coverage:** ✅ 1 test (integration)
**Mitigates Risks:** Data inconsistency, partial schema changes

**Implementation Note:** Use pytest monkeypatch or unittest.mock to simulate database failure during audit creation.

---

#### AC7: Database Index on session_id

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-API-001** | API | **P1** | `test_session_id_index_exists()` - Query database metadata to verify index exists on component_audit_logs.session_id | Validates migration applied correctly |

**Coverage:** ✅ 1 test (API/database validation)
**Mitigates Risks:** Performance degradation on audit queries

**Note:** P1 priority because index existence can be verified through migration history. Performance impact is low-risk since audit queries are infrequent.

---

#### AC8: Type-Locking Removed

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-INT-007** | Integration | **P1** | `test_schema_change_allowed_with_existing_data()` - Create component with schema A and dynamic_data, change to schema B, verify success (no ValueError) | Validates type-locking removal |

**Coverage:** ✅ 1 test (integration)
**Mitigates Risks:** Regression to old blocking behavior

**Note:** P1 because this is a negative test (ensuring old behavior is gone). Primary validation is that other tests don't fail.

---

### Frontend Display (AC9-13)

#### AC9-13: History Tab Integration, Grouped Display, Formatting

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-E2E-001** | E2E | **P1** | `test_component_history_displays_audit_records()` - Open component with audit history, click History tab, verify records displayed with correct grouping and formatting | Critical user-facing validation |

**Coverage:** ✅ 1 test (E2E)
**Mitigates Risks:** UI regression, poor UX

**Why E2E?** Frontend testing is best done as an end-to-end test since it validates the complete chain: backend API → frontend API client → React component → user interaction. Unit testing React components requires extensive mocking and provides less confidence.

**Alternative (P2):** Could add React Testing Library unit tests for ComponentHistory, but E2E provides better ROI for this read-only display feature.

---

### API Layer (AC14-16)

#### AC14-16: Audit History Endpoint, Query Parameters, Response Model

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-API-002** | API | **P0** | `test_get_audit_history_returns_records()` - GET /flexible-components/{id}/audit-history, verify 200 response with array of audit records | Tests API contract |
| **3.16-API-003** | API | **P0** | `test_audit_history_query_parameters()` - Test session_id filter and limit parameter, verify correct filtering and pagination | Tests query parameter handling |
| **3.16-INT-008** | Integration | **P1** | `test_audit_history_for_nonexistent_component()` - GET /flexible-components/{invalid-id}/audit-history, verify 404 response | Tests error handling |

**Coverage:** ✅ 3 tests (2 API, 1 integration)
**Mitigates Risks:** API contract violations, breaking changes

---

### Quality Requirements (AC17-19)

#### AC17: Test Coverage

**Covered by all tests in this design** - This AC is satisfied by writing the 18 tests above.

---

#### AC18: Performance (<50ms audit creation)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-PERF-001** | Performance | **P2** | `test_audit_creation_performance_benchmark()` - Create 100 audit records in loop, measure average time, assert < 50ms per audit | Validates AC18 requirement |

**Coverage:** ✅ 1 test (performance benchmark)
**Mitigates Risks:** Performance degradation

**Note:** P2 because current implementation (2 simple INSERTs) is highly unlikely to exceed 50ms. Benchmark is useful for regression detection but not critical for initial release.

---

#### AC19: Data Integrity (no FK constraints)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| **3.16-INT-009** | Integration | **P1** | `test_audit_survives_component_deletion()` - Create component with audit, delete component, verify audit records still exist | Validates AC19 requirement |

**Coverage:** ✅ 1 test (integration)
**Mitigates Risks:** Unintended cascade deletion

---

## Test Execution Priority & Order

### Phase 1: Critical Path (P0) - **Must Pass Before Merge**

**Unit Tests** (Fast, ~2 seconds total):
1. ✅ 3.16-UNIT-001: Two records created
2. ✅ 3.16-UNIT-002: Session ID linking
3. ✅ 3.16-UNIT-003: Schema record field name
4. ✅ 3.16-UNIT-004: Dynamic data record field name
5. ✅ 3.16-UNIT-005: JSON serialization
6. ✅ 3.16-UNIT-006: NULL guard

**Integration Tests** (Slower, ~15 seconds total):
7. ✅ 3.16-INT-001: Full schema change workflow
8. ✅ 3.16-INT-002: Schema UUID capture
9. ✅ 3.16-INT-003: Dynamic data preservation
10. ✅ 3.16-INT-004: First assignment skip
11. ✅ 3.16-INT-005: Same schema skip
12. ✅ 3.16-INT-006: Transaction rollback

**API Tests** (Medium, ~5 seconds total):
13. ✅ 3.16-API-002: Endpoint returns records
14. ✅ 3.16-API-003: Query parameters

**Total P0: 14 tests, ~22 seconds**

---

### Phase 2: Important (P1) - **Should Pass Before Production**

15. ✅ 3.16-API-001: Index exists
16. ✅ 3.16-INT-007: Type-locking removed
17. ✅ 3.16-INT-008: 404 for nonexistent component
18. ✅ 3.16-INT-009: Audit survives deletion
19. ✅ 3.16-E2E-001: History tab displays correctly

**Total P1: 5 tests, ~30 seconds (includes E2E)**

---

### Phase 3: Nice-to-Have (P2) - **Run Periodically**

20. ✅ 3.16-PERF-001: Performance benchmark

**Total P2: 1 test, ~3 seconds**

---

## Risk Coverage Analysis

**High-Priority Risks Mitigated:**

| Risk | Probability | Impact | Risk Score | Test Coverage |
|------|-------------|--------|------------|---------------|
| **Data Loss** (audit not created) | Medium | High | **8/10** | 3.16-INT-001, 3.16-INT-003 |
| **Transaction Failure** (partial update) | Low | High | **6/10** | 3.16-INT-006 |
| **Audit Bloat** (unnecessary records) | Medium | Low | **4/10** | 3.16-INT-004, 3.16-INT-005 |
| **API Contract Break** (breaking change) | Low | Medium | **4/10** | 3.16-API-002, 3.16-API-003 |
| **Serialization Failure** (JSONB→JSON) | Low | Medium | **4/10** | 3.16-UNIT-005 |

**All high-risk scenarios (score ≥6) have P0 test coverage.**

---

## Coverage Verification

✅ **Every AC has test coverage:**

| AC # | Description | Test IDs |
|------|-------------|----------|
| AC1 | 2 linked records | 3.16-UNIT-001, 3.16-UNIT-002, 3.16-INT-001 |
| AC2 | Schema record format | 3.16-UNIT-003, 3.16-INT-002 |
| AC3 | Data preservation | 3.16-UNIT-004, 3.16-UNIT-005, 3.16-INT-003 |
| AC4 | Skip NULL | 3.16-UNIT-006, 3.16-INT-004 |
| AC5 | Skip same schema | 3.16-INT-005 |
| AC6 | Transaction rollback | 3.16-INT-006 |
| AC7 | Index exists | 3.16-API-001 |
| AC8 | Type-locking removed | 3.16-INT-007 |
| AC9-13 | Frontend display | 3.16-E2E-001 |
| AC14-16 | API endpoint | 3.16-API-002, 3.16-API-003, 3.16-INT-008 |
| AC17 | Test coverage | (This test design) |
| AC18 | Performance | 3.16-PERF-001 |
| AC19 | Data integrity | 3.16-INT-009 |

**Coverage:** 19/19 ACs = **100%** ✅

---

## Test Implementation Guide

### File Structure

Create/modify these test files:

```
backend/tests/
├── test_audit_service.py (CREATE NEW)
│   └── Contains: 3.16-UNIT-001 through 3.16-UNIT-006
│
├── test_flexible_component_service.py (MODIFY EXISTING)
│   └── Add: 3.16-INT-001 through 3.16-INT-009
│
└── test_component_audit_api.py (CREATE NEW)
    └── Contains: 3.16-API-001 through 3.16-API-003

frontend/tests/e2e/
└── component-history.spec.ts (CREATE NEW)
    └── Contains: 3.16-E2E-001
```

### Sample Test Implementation

**Example: 3.16-UNIT-001**

```python
# backend/tests/test_audit_service.py
import pytest
from app.services.audit_service import AuditService
from app.models.database import ComponentAuditLog
from uuid import uuid4

@pytest.mark.asyncio
async def test_create_schema_change_audit_creates_two_records(db_session):
    """Test that create_schema_change_audit creates exactly 2 linked records"""
    # Arrange
    audit_service = AuditService(db_session)
    component_id = uuid4()
    old_schema_id = uuid4()
    new_schema_id = uuid4()
    old_dynamic_data = {"result": 10.0, "inspect": True}

    # Act
    session_id = audit_service.create_schema_change_audit(
        component_id=component_id,
        old_schema_id=old_schema_id,
        new_schema_id=new_schema_id,
        old_dynamic_data=old_dynamic_data,
        changed_by="test-user"
    )

    # Assert
    audit_records = db_session.query(ComponentAuditLog).filter_by(
        component_id=component_id
    ).all()

    assert len(audit_records) == 2, "Should create exactly 2 audit records"
    assert audit_records[0].session_id == session_id
    assert audit_records[1].session_id == session_id
```

**Example: 3.16-INT-006 (Transaction Rollback)**

```python
# backend/tests/test_flexible_component_service.py
import pytest
from unittest.mock import patch
from app.services.flexible_component_service import FlexibleComponentService
from app.models.schema import FlexibleComponentUpdate

@pytest.mark.asyncio
async def test_audit_failure_rolls_back_schema_change(db_session, component_with_schema):
    """Test that schema change is rolled back if audit creation fails"""
    # Arrange
    service = FlexibleComponentService(db_session)
    original_schema_id = component_with_schema.schema_id
    new_schema_id = uuid4()

    # Mock db.flush() to simulate audit failure
    with patch.object(db_session, 'flush', side_effect=Exception("Audit insert failed")):
        # Act & Assert
        with pytest.raises(ValueError, match="Schema change aborted"):
            await service.update_flexible_component(
                component_with_schema.id,
                FlexibleComponentUpdate(schema_id=new_schema_id)
            )

    # Verify rollback: schema_id unchanged
    db_session.refresh(component_with_schema)
    assert component_with_schema.schema_id == original_schema_id

    # Verify no audit records created
    audit_records = db_session.query(ComponentAuditLog).filter_by(
        component_id=component_with_schema.id
    ).all()
    assert len(audit_records) == 0
```

---

## Maintenance Considerations

**Test Maintenance Effort:** LOW
- Tests are focused on stable audit API (unlikely to change)
- Integration tests use fixtures for component setup (reusable)
- No complex UI interactions (one E2E test only)

**Future Test Additions:**
- If audit recovery/restore feature added, add tests for undo workflow
- If auth integration added, update tests to use real user IDs instead of NULL

---

## Quality Checklist

✅ Every AC has test coverage (100%)
✅ Test levels are appropriate (shift-left: 6 unit, 8 integration, 1 E2E)
✅ No duplicate coverage across levels
✅ Priorities align with business risk (12 P0 for critical path)
✅ Test IDs follow naming convention (3.16-{LEVEL}-{SEQ})
✅ Scenarios are atomic and independent

---

## Summary for Gate YAML

```yaml
test_design:
  scenarios_total: 18
  by_level:
    unit: 6
    integration: 9
    api: 3
    e2e: 1
    performance: 1
  by_priority:
    p0: 12
    p1: 5
    p2: 1
  coverage_gaps: []  # All 19 ACs covered
  estimated_execution_time: "55 seconds (P0+P1)"
  recommended_ci_tests: "P0 tests (14 tests, ~22 seconds)"
```

---

**Test Design Complete** ✅

This design provides comprehensive coverage with efficient test distribution. The 12 P0 tests (~22 seconds) should run on every commit, while P1 tests can run before production deployment.
